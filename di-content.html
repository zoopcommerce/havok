<!-- Subhead
================================================== -->
<header class="jumbotron subhead" id="overview">
  <div class="container">
    <h1>Dependency Injection</h1>
    <p class="lead">Your gateway to loosely coupled and flexible code.</p>
  </div>
</header>


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span3 bs-docs-sidebar">
        <ul data-dojo-type="havok/widget/NavList"
            data-dojo-mixins="havok/widget/_AffixMixin, havok/widget/_ScrollSpyMixin"
            data-dojo-props="
               linkTemplate: '&lt;a role=&quot;navitem&quot; href=&quot;${href}&quot;&gt;&lt;i class=&quot;icon-chevron-right&quot;&gt;&lt;/i&gt; ${text}&lt;/a&gt;',
               viewportOffset: {top: 40, bottom: 0},
               affixTarget: 'mainContent',
               spyTarget: 'mainContent'
            "
            class="nav-stacked bs-docs-sidenav"
        >
        </ul>
      </div>
    <div class="span9" id="mainContent">

        
        <section id="overview" title="Overview">
          <div class="page-header">
            <h1>Overview</h1>
          </div>

            <p class="lead">So, what is dependency injection...</p>

            <p>Dependency Injection removes what can sometimes be the mess of configuring modules and the resources they need to consume from the normal flow of code. Instead of long constructor functions and complex constructor arguments, configuration is defined in a confie module, and the di container does all the wiring up for you. It removes hard dependencies from code, and configuration can be easily altered for different needs.</p>

            <h2>Example</h2>
            <p>When the <code>havok/exception/handler</code> renders an exception to the console, it uses <code>havok/exception/ConsoleLogRenderer</code>. If you write your own improved renderer, you can use it with this simple change to the config:</p>

<pre class="prettyprint linenums">
di: {
    'havok/exception/Handler': {
        gets: {
            consoleLogRenderer: 'my/new/Renderer'
        },
    }
}
</pre>

            <h2>Creation</h2>

<p>There can be multiple di containers. A di container is created like this:

<pre class="prettyprint linenums">
require(['havok/di/Di'], function(Di){
    var di = new Di({/*my config*/});
}
</pre>

<h2>Config</h2>

<p>The behaviour of the di container is controlled by the config object.</p>

<p>The config object can be explicitly passed to the constructor:</p>

<pre class="prettyprint linenums">
var di = new Di({/*put configuration here*/});
</pre>

The config object can be set after the di container has been created:

<pre class="prettyprint linenums">
di.setConfig({/*put configuration here*/});
</pre>

<p>If no config object is supplied to the constructor, the <code>di</code> key from the dojo config object will be used.</p>

<p>The a config object can be merged with the existing di config using the mergeConfig method:</p>

<pre class="prettyprint linenums">
di.mergeConfig({/*put config to merge here*/});
</pre>

<p>The config for an individual identifier can be set with:</p>

<pre class="prettyprint linenums">
di.setIdentifierConfig(identifier, {/* put config here*/});
</pre>

<p>For docs of the config format, see below.</p>

<h2>sharedDi!</h2>

<p>Other Havok use one common di container configured with the dojo config object. This allows the di config to be merged by <code>havok/config/manager</code>.</p>

<p>To get the shared di container use the AMD plugin:</p>

<pre class="prettyprint linenums">
require(['havok/di/sharedDi!'], function(sharedDi){
    //do something
}
</pre>

<h2>Retrieving objects</h2>

<p>To fetch an object from the di you need to pass the di an identifier. The di will look the identifier up in the config, do any injections, and pass the result back to you. An object can be fetched from the di with three different methods:</p>

<table class="table table-bordered table-striped">
  <thead>
   <tr>
     <th style="width: 100px;">name</th>
     <th>description</th>
   </tr>
  </thead>
  <tbody>
    <tr>
        <td>di.get(identifier)</td>
        <td>Simple and clear. It gets an object.</td>
    </tr>
    <tr>
        <td>di.create(identifier)</td>
        <td>Creates an object, ignoring any object already cached with the identifier.</td>
    </tr>
    <tr>
        <td>di.proxy(identifier)</td>
        <td>Gets a proxy, or a stand-in for the object. Good for lazy loading.</td>
    </tr>
  </tbody>
</table>

<p>The differences between these methods are explained more below.</p>

        </section>

        <section id="config-format" title="Config Format">
          <div class="page-header">
            <h1>Config Format</h1>
          </div>

<p>The property names of the config object are identifiers. They are used to retrieve configured objects from the di. The properies themselves define how the object will be injected. The property object can have the following sub properties. All sub properties are optional:</p>

<table class="table table-bordered table-striped">
  <thead>
   <tr>
     <th style="width: 100px;">name</th>
     <th style="width: 50px;">type</th>
     <th>description</th>
   </tr>
  </thead>
  <tbody>
    <tr>
        <td>base</td>
        <td>string</td>
        <td>Specify which module will be the base, or foundation for injection.</td>
    </tr>
    <tr>
        <td>params</td>
        <td>object</td>
        <td>Specifies static parameters to be injected.</td>
    </tr>
    <tr>
        <td>gets</td>
        <td>object</td>
        <td>Specifies objects that should be retrieved through the di and injected.</td>
    </tr>
    <tr>
        <td>proxies</td>
        <td>object</td>
        <td>Specifies object that should be proxied by the di and injected.</td>
    </tr>
    <tr>
        <td>directives</td>
        <td>object</td>
        <td>A set of flags that give fine grained control over di injection behaviour.</td>
    </tr>
    <tr>
        <td>proxyMethods</td>
        <td>array</td>
        <td>An array of methods that should be available when creating a proxy.</td>
    </tr>
  </tbody>
</table>

        </section>

        <section id="base" title="base">
          <div class="page-header">
            <h1>base</h1>
          </div>

<p class="lead">Tell di which object injections should be applied to.</p>

<p>The base defines which object the di will inject. For example, with this config <code>di.get('myIdentifier')</code> will get an instance of <code>my/module</code> with the <code>color</code> property set to blue.</p>

<pre class="prettyprint linenums">
'myIdentifier': {
    base: 'my/module',
    params: {
        color: 'blue'
    }
},
</pre>

<h3>Ommited Base</h3>
<p>If the base is ommitted, the identifier is assumed to be the base. Eg:</p>

<pre class="prettyprint linenums">
'my/module': {
    params: {
        color: 'blue'
    }
},
</pre>

<h3>Chaining</h3>
<p>If base is set to a string, the base will be fetched through the di. This allows chaining. </p>

<p>For example, with this config <code>di.get('myIdentifier')</code> will get an instance of <code>my/module</code> with the <code>color</code> property set to blue and <code>size</code> property set to big.</p>
<pre class="prettyprint linenums">
'my/module': {
    params: {
        color: 'blue'
    }
},
'myIdentifier: {
    base: 'my/module',
    params: {
        size: 'big'
    }
}
</pre>

<h3>Identifier without config</h3>
<p>If an identifier is not configured, the di will assume it is a module, and just load that module using <code>require</code>.</p>

<h3>Object base</h3>

<p>If the base is an object, rather than a string, that object will be used for injection.</p>

<p>For example, with this config <code>di.get('myIdentifier')</code> will return <code>{size: 'big'}</code>.</p>
<pre class="prettyprint linenums">
'myIdentifier: {
    base: {},
    params: {
        size: 'big'
    }
}
</pre>

        </section>

        <section id="params" title="params">
          <div class="page-header">
            <h1>params</h1>
          </div>

<p class="lead">Scalar values to be injected</p>

<p>Any property set in the <code>params</code> object will be set on the returned object.</p>

<p>For example:</p>
<pre class="prettyprint linenums">
'my/module': {
    params: {
        color: 'blue',
        size: 'big',
        number: 6,
        something: {blah: 4}
    }
}
</pre>

        </section>

        <section id="gets" title="gets">
          <div class="page-header">
            <h1>gets</h1>
          </div>

<p class="lead">Objects to be injected</p>

<h2>Simple get</h2>
<p>Any property set in the <code>gets</code> object will be fetched through the di and then set on the returned object.</p>

<p>For example, with this config <code>di.get('my/zoo')</code> will return an instance of <code>my/zoo</code> populated with one lion and two tigers. The two tigers will have different names.</p>
<pre class="prettyprint linenums">
'my/zoo': {
    gets: {
       lion: 'my/lion/module',
       tiger1: 'tiger1',
       tiger2: 'tiger2
    }
},
'tiget1': {
    base: 'my/tiger/module',
    params: {
        name: 'Toby'
    }
},
'tiget1': {
    base: 'my/tiger/module',
    params: {
        name: 'Alice'
    }
}
</pre>

<h2>Inline config</h2>

<p>Rather than specifying a string in a get, you can use an inline config to make the code more consise and easier to read. The example above could be rewritten as:</p>

<pre class="prettyprint linenums">
'my/zoo': {
    gets: {
       lion: 'my/lion/module',
       tiger1: {
            base: 'my/tiger/module',
            params: {
                name: 'Toby'
       },
       tiger2: {
            base: 'my/tiger/module',
            params: {
                name: 'Alice'
       }
    }
}
</pre>

        </section>

        <section id="proxies" title="proxies">
          <div class="page-header">
            <h1>Proxies</h1>
          </div>

<p class="lead">Objects to proxy, then inject</p>

<p>Proxy objects can be injected with exactly the same synatx as <code>gets</code>, the only difference being a proxy is injected instead of the actual object.</p>

<p>For example:</p>
<pre class="prettyprint linenums">
'my/zoo': {
    proxy: {
       lion: 'my/lion/module',
       tiger1: {
            base: 'my/tiger/module',
            params: {
                name: 'Toby'
       },
       tiger2: {
            base: 'my/tiger/module',
            params: {
                name: 'Alice'
       }
    }
}
</pre>

<p>For information on proxy object and why you might use them, see the Proxy Objects section.</p>

        </section>

        <section id="directives" title="directives">
          <div class="page-header">
            <h1>directives</h1>
          </div>

<p class="lead">Fine grained control over fetching objects</p>

<p>There are four possible directives. Each is a boolean flag.</p>

<p>The default directives are:</p>
<pre class="prettyprint linenums">
directives: {
    declare: false,
    define: false,
    cache: true,
    clone: false
};
</pre>

<h2>cache</h2>

<p>The di container automatically caches objects. If you want to recreate the object every time <code>di.get()</code> is called, then set <code>cache: false</code>.

<p>For example:</p>
<pre class="prettyprint linenums">
'my/module': {
    directives: {
        cache: false
    }
}
</pre>

<h2>declare</h2>

<p>If the declare directive is set to true, then <code>dojo/_base/declare</code> will be used on the injected object, and a contstructor returned rather than an istance. This is especially useful for injecting widgets that are created by the parser. eg if this config is set:</p>

<pre class="prettyprint linenums">
'object1': {
    base: 'dijit/Form/TextBox',
    directives: {
        declare: true
    },
    params: {
        a: 1
    }
}
</pre>

<p>Then this markup could be used:</p>

<pre class="prettyprint linenums">
&lt;script type=&quot;text/javascript&quot;&gt;
    require([
        'dojo/parser',
        'get!object1',
    ],
    function(parser){
        parser.parse()
    })
&lt;/script&gt;

&lt;div data-dojo-type: 'object1'&gt;&lt;/div&gt;
</pre>

<p>This would result in a TextBox with a = 1.</p>

<h2>define</h2>

<p>If define is set to true, a new AMD module is defined with the identifier. eg, if this config is set:</p>

<pre class="prettyprint linenums">
'object1': {
    base: 'My/Module',
    directives: {
        define: true
    },
    params: {
        a: 1
    }
}
</pre>

<p>The the following code could be run:</p>

<pre class="prettyprint linenums">
require([get!object1], function(object1){})
</pre>

<p>Later in code, if object1 is required again, becasue and AMD module has been defined, the get! is no longer needed. eg:</p>

<pre class="prettyprint linenums">
require([object1], function(object1){})
</pre>

<h2>clone</h2>

<p>For objects that do not have a prototype, the base is whatever is returned by the AMD loaded. If you want to clone the base before injection, set <code>clone: true</code>.</p>

<p>For example:</p>
<pre class="prettyprint linenums">
'my/module': {
    directives: {
        clone: false
    }
}
</pre>
        </section>

        <section id="injecting-arrays" title="Injecting Arrays">
          <div class="page-header">
            <h1>Injecting Arrays</h1>
          </div>

<p>Arrays of values and objects can be injected, and elements from those arrays can be defined in different parts of the config.</p>

<p>This config will result in a <code>my/zoo</code> instance with an array of six different animals:</p>

<pre class="prettyprint linenums">
'my/zoo': {
    params: {
        animals: [
            'cobra',
            'crocodile'
        ]
    },
    gets: {
        animals: [
            'lion1',
            'lion2'
        ]
    },
    proxies: {
        animals: [
            'tiger',
            {
                base: 'penguin',
                name: 'Percy'
            }
        ]
    }
}
</pre>

        </section>

        <section id="proxy-objects" title="Proxy Objects">
          <div class="page-header">
            <h1>Proxy Objects</h1>
          </div>

<p>It's all great and wonderful to inject objects here and there, but what if you have an object that only might be used? You don't want to go through the overhead of creating, particularly if it requires extra code to be loaded from the server if it is only rarely used. It's time to use a Proxy.</p>

<p>A proxy object is a stand in for the real object. Di can create a proxy, and the real object will only be created when the proxy is first used. Proxy object will be injected with their own configured <code>params</code> and <code>proxies</code> when the proxy is created. However, they will not be injected with any configured <code>gets</code> until first method call on the proxy.</p>

<p>When creating a proxy, the di needs to be told what methods are available for proxying. This is what the <code>proxyMethods</code> configuration is used for.</p>

<p>For example, with this config <code>di.get('my/zoo')</code> will return an instance of <code>my/zoo</code> populated with a proxy lion. The <code>my/lion/module</code> will not be created until <code>zoo.lion.roar()</code> is called.</p>

<pre class="prettyprint linenums">
'my/zoo': {
    proxy: {
       lion: 'my/lion/module'
    }
}
'my/lion/module': {
    proxyMethods: [
        'roar'
    ]
}
</pre>

<p>Note: Proxied methods may return a Deferred which will resolve to the proxied method's result. This is because fetching the insance through the di may involve asyncronous loading.</p>

<p>Every proxy also has a <code>diGet()</code> function that can force the di to load the proxy's underlying instance.</p>

        </section>

        <section id="plugins" title="Plugins">
          <div class="page-header">
            <h1>Plugins</h1>
          </div>

<p>There are two AMD plugins provided which mean you can largely forget di in your actual code.</p>

<h2>get!</h2>

<p>Using <code>havok/get!my/module</code> will return an instance of <code>my/module</code> retrieved through the shared di container. Eg:</p>

<p>When creating a proxy, the di needs to be told what methods are available for proxying. This is what the <code>proxyMethods</code> configuration is used for.</p>

<p>For example, with this config <code>di.get('my/zoo')</code> will return an instance of <code>my/zoo</code> populated with a proxy lion. The <code>my/lion/module</code> will not be created until <code>zoo.lion.roar()</code> is called.</p>

<pre class="prettyprint linenums">
require(['havok/get!my/module'], function(myModule){
    //do something
})
</pre>

<h2>proxy!</h2>

<p><code>havok/proxy!</code> works exactly the same as <code>havok/get!</code>, it just returns a proxy instead:</p>

<pre class="prettyprint linenums">
require(['havok/proxy!my/module'], function(myModule){
    //do something
})
</pre>
        </section>

        <section id="build" title="build">
          <div class="page-header">
            <h1>Build</h1>
          </div>

<p>When doing dojo builds, it is strongly recommended that you use the havok build tools. If you do, di plugins will resolve at build time with the following behaviour:</p>

<h2>havok/get!</h2>

<p>Will include <code>havok/di/di</code>, and the module requested by get!, and any modules in the gets property of the config for that object.</p>

<h2>havok/proxy!</h2>

<p>Will include <code>havok/di/di</code>, but not the module requested by proxy!.</p>

<h2>havok/di/sharedDi!</h2>

<p>Will include <code>havok/di/di</code>.

        </section>
      </div>
    </div>

  </div>
